

# Binary_search

## 普通情况

即1 3 4 6 7 8里寻找一个特定的数

1. 推导过程：

2. 图解：

   ![img](https://wx1.sinaimg.cn/mw690/005LasY6gy1gc393ymtczj31d60u01kx.jpg)

   PS:

   + 如果查找到，可能有两种情况

     + 一是head和tail没重合，arr[mid]是那个值
     + 二是最后head和tail重合了，arr[mid]是那个值

   + 为什么while()里写head <= tail呢？

     因为就算head == tail了，也有可能不是要找的那个数！！！！(对比一下后两种二分！！)

   代码如下

   ```C
   int binary_search1(int *arr, int n, int x) {//要在长度为n的数组中查找x，存在返回下标，不存在返回-1
     int head = 0, tail = n - 1, mid;
     while (head <= tail) {//为什么是<=呢？因为就算头尾指针重合，也有可能找到的不是那个数
       mid = (head + tail) >> 1;
       if (arr[mid] == x) return mid;
       if (arr[mid] < x) head = mid + 1;
       else tail = mid - 1;
     }
     return -1;//走到这一步说明没找到
   }
   ```





## 特殊情况1

即1111110000找最后一个1这种情况(找最后一个符合条件的值！！)

0. 图解：

![img](https://wx3.sinaimg.cn/mw690/005LasY6gy1gc3a5zqcjfj318j0u07ue.jpg)

1. 整体不变，只需要改动几个地方就行！

   + while ()里写head < tail！

     因为重合就说明一定可判断！要么就是找到了，要么就是全是0！

     PS:

     + 朴素的二分里如果重合也一定可判断，但它本身的while里的逻辑也可判断！！所以就不用跳出来判断了！

     + 那问题就来了，这种情况下，如果重合，本身while里的逻辑不能判断吗？

       确实不行！如果while()里依然写head <= tail的话，如果成功找到了那个位置，由于下一行的改动(head = mid)，会一直死循环！ 

   + if (arr[mid] == 1) head = mid;

     因为可能是最后一个1

   + if (arr[mid] != 1) tail = mid - 1;

     这个不用变

   + 边界条件呢？

     + 全是1，最后肯定能找到最后一个1，不用特判

     + 全是0，最后肯定head和tail重合在1，还用特判

       这里采用一个技巧：虚拟头指针，即head一开始指向-1，如果最后没找到，肯定返回的是-1！！

   + 经过调试，还有最终的一个bug，就是mid要 = (head + tail + 1) >> 1

     因为由于/是向0取整的，会造成死循环，栗子：5，6位置上分别是1、0。(根本原因还是因为head = mid的那个改动！)

2. 代码如下

   ```C
   int binary_search2(int *arr, int n) {
     int head = -1, tail = n - 1, mid;
     while (head < tail) {
       mid = (head + tail + 1) >> 1;
       if (arr[mid] == 1) head = mid;
       else tail = mid - 1;
     }
     return head;//如果是000000，则返回-1， 妙啊！！
   }
   ```

   

## 特殊情况2

即000001111寻找第一个1

0. 图解：(这个图解有错误！！)

   ![img](https://wx4.sinaimg.cn/mw690/005LasY6gy1gc3a98n6usj31be0u0u0c.jpg)

   1. 思路：和特殊情况1基本类似，只有以下改动

      + mid还是=(head + tail) >> 1;

        这里不存在死循环的问题，因为要找的在后面，不会造成head和tail永远不重合！

      + 虚拟头指针改成虚拟尾指针了！

   2. 代码如下：

   ```C
   int binary_search3(int *arr, int n) {
     int head = 0, tail = n, mid;
     while (head < tail) {
       mid = (head + tail) >> 1;
       if (arr[mid] = 1) tail = mid;//这个地方图解写错了！
       else head = mid + 1;
     }
     return tail == n ? -1 : tail;//虚拟尾指针的作用！！！
   }
   ```



## 集大成写法(风骚写法)

1. 思路

   就是大体思路不变，但是循环到最后还剩几个元素时改为顺序查找！！

2. 代码如下

   ```c
   int binart_search(int *arr, int n, int x) {
     int head = 0, tail = n - 1, mid;
     while (head + 3 <= tail) {
       mid = (head + tail) >> 1;
       if (arr[mid] == x) return mid;
       if (arr[mid] < x) head = mid + 1;
       else tail = mid - 1;
     }
     for (int i = head, i <= tail; i++) {
       if (arr[i] == x) return i;
     }
     return -1;
   }
   ```

   

# Hashtable

## 综述

1. 哈希表又叫散列表，关键值通过哈希函数映射到数组上，查找时通过关键值直接访问数组。
2. 哈希函数指的是关键值和存储位置建立的对应关系， 查找时只要根据这个关系就能找到目标位置。一般我们只要通过一次查找就能找到目标位置，但有些关键字需要多次比较和查找才能找到，这是为什么呢？因为哈希表里，可能存在关键字不同但是哈希地址相同的情况，也就是产生了冲突。一般情况下，冲突是不可避免的，因为关键字集合往往比哈希地址集合大很多。

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gc244gchvcj319k0fadnt.jpg)

3. 要提高哈希表的查找效率，关键在于合理地构造哈希函数和优秀的解决冲突的方法。

## 哈希函数

1. 哈希函数的优劣直接影响到哈希表查找的效率，优秀的哈希函数可以减少冲突的发生，哈希表里的元素可以是不同类型的，也可以是不同规律的，所以不同情况下哈希函数的设计也是不同的。

2. 常见构造方法：

   + 直接寻址法

     即取关键字的值或者关键字的某个函数变换值，线性地映射到存储地址上。如果关键字的数量和跨度不是很大，直接寻址法是最简单有效的构造方法了，并且还可以避免冲突。但是如果关键字的数量和跨度很大的话，这种方法就用不了了，例如有n个关键字，值最小的为0，最大的为pow(10, 10)，这种情况下就不能用直接寻址法了，因为没有足够的空间可以用来存储。

   + 除留余数法

     我们将关键字对整数p取的余数直接作为存储地址，整数p一般取小于等于哈希表长度size的最大质数，如果关键字不是整数，比如是一个字符串，可以先将其做个转换，然后再对p取余。选择优秀的p可以减少冲突的发生。

   + 分析数字法、随机数法……

3. 设计哈希函数没有统一的方法，同一个哈希函数不一定能使用所有问题，其产生的影响也是不一样的。但哈希函数的设计又是至关重要的，那么我们应该如何设计呢？一般来说，设计哈希函数时要达到两个要求：

   + 计算简单

     计算复杂的哈希函数会增加查询的时间。

   + 关键字尽可能地均分到存储地址上，这样可以减少冲突。



## 处理冲突的办法

1. 首先我们了解到可以通过构造优秀的哈希函数来减少冲突，但是一般情况下冲突是不可避免的，而解决冲突的方法也会影响哈希表的查找效率，因此选择一个优秀的方法来处理冲突显得尤为重要。

2. 开放地址法

   如果发生冲突，那么就使用某种策略寻找下一存储地址，知道找到一个不冲突的地址或者找到关键字，否则一直按这种策略继续寻找。如果冲突次数达到了上限则终止程序，表示关键字不存在哈希表里。

   一般常见的策略有这么几种：

   + 线性探测法：如果当前的冲突位置为d，那么接下来几个探测地址为d+1, d+2,d+3等，也就是从冲突地址往后面一个一个探测。
   + 线性补偿探测法：它形成的探测地址为d+m,d+2m, d+3m等，与线性探测法不同，这里的查找单位不是1，而是m，为了能遍历到哈希表里所有位置，我们设置m和表长size互质。
   + 随机探测法，这种方法和前两种方法类似，这里的查找单位不是一个固定值，而是一个随机序列。
   + 二次探测法，它形成的探测地址为d+1^2, d-1^2, d+2^2, d-2^2等，这种方法在冲突位置左右跳跃着寻找探测地址。

   开放地址法计算简单快捷，处理起来方便，但是也存在不少缺点。

   线性探测法容易形成“堆聚”的情况，即很多记录就连在一块，而且一旦形成“堆聚”，记录会越聚越多。

   另外，开放地址法都有一个缺点，删除操作显得十分复杂，我们不能直接删除关键字所在的记录，否则在查找删除位置后面的元素时，可能会出现找不到的情况，因为删除位置上已经成了空地址，查找到这里时会终止查找。

3. 链地址法

   该方法将所有哈希地址相同的结点链成一个单链表，单链表的头结点存在哈希数组里。链地址法常出现在经常插入和删除的情况下。

   相比开放地址法，链地址法有以下优点：

   + 不会出现“堆聚”现象，哈希地址不同的关键字不会发生冲突。

   + 不需要重建哈希表。

     在开放地址法中，如果哈希表里存满关键字了就需要扩充哈希表然后重建哈希表，而在链地址法里，因为结点都是动态申请的，所以不会出现哈希表里存满关键字的情况。

   + 关键字删除更方便，只需要找到指定结点的前驱，删除该结点即可。

4. 开放地址法和链地址法各有千秋，适用于不同的情况

   + 关键字规模少的时候，开放地址法比链地址法更省空间，因为用链地址法可能会存在哈希数组出现大量空地址的情况。
   + 关键字规模大的时候，链地址法就比开放地址法更省空间，链表产生的指针域可以忽略不计，关键字多，哈希数组里的空地址就少了。