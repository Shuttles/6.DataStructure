# 

# 1.综述

1. 哈希表又叫散列表，**关键值通过哈希函数映射到数组上，查找时通过关键值直接访问数组**。
2. 哈希函数指的是**关键值和存储位置建立的对应关系**， 查找时只要根据这个关系就能找到目标位置。一般我们只要通过**一次查找**就能找到目标位置，但有些关键字需要多次比较和查找才能找到，这是为什么呢？因为哈希表里，可能存在关键字不同但是哈希地址相同的情况，也就是产生了冲突。一般情况下，冲突是不可避免的，因为关键字集合往往比哈希地址集合大很多。

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gc244gchvcj319k0fadnt.jpg)

3. 要提高哈希表的查找效率，关键在于**合理地构造哈希函数**和**优秀的解决冲突**的方法。

# 2.哈希函数

1. 哈希函数的优劣直接影响到哈希表查找的效率，优秀的哈希函数可以减少冲突的发生，哈希表里的元素可以是不同类型的，也可以是不同规律的，所以不同情况下哈希函数的设计也是不同的。

2. 常见构造方法：

   + **直接寻址法**

     即取关键字的值或者关键字的某个函数变换值，线性地映射到存储地址上。如果关键字的数量和跨度不是很大，直接寻址法是最简单有效的构造方法了，并且还可以避免冲突。但是如果关键字的数量和跨度很大的话，这种方法就用不了了，例如有n个关键字，值最小的为0，最大的为pow(10, 10)，这种情况下就不能用直接寻址法了，因为没有足够的空间可以用来存储。

   + **除留余数法**

     我们将关键字对整数p取的余数直接作为存储地址，整数p一般取**小于等于哈希表长度size的最大质数**，如果关键字不是整数，比如是一个字符串，可以先将其做个转换，然后再对p取余。选择优秀的p可以减少冲突的发生。

   + **分析数字法、随机数法**……

3. 设计哈希函数没有统一的方法，同一个哈希函数不一定能使用所有问题，其产生的影响也是不一样的。但哈希函数的设计又是至关重要的，那么我们应该如何设计呢？一般来说，设计哈希函数时要达到两个要求：

   + **计算简单**

     计算复杂的哈希函数会增加查询的时间。

   + **关键字尽可能地均分到存储地址上，这样可以减少冲突**。



# 3.冲突处理方法

1. 首先我们了解到可以通过构造优秀的哈希函数来减少冲突，但是一般情况下冲突是不可避免的，而解决冲突的方法也会影响哈希表的查找效率，因此选择一个优秀的方法来处理冲突显得尤为重要。

2. **开放地址法**

   如果发生冲突，==那么就使用某种策略寻找下一存储地址，直到找到一个不冲突的地址或者找到关键字，否则一直按这种策略继续寻找==。如果冲突次数达到了上限则终止程序，表示关键字不存在哈希表里。

   一般常见的策略有这么几种：

   + **线性探测法**：如果当前的冲突位置为d，那么接下来几个探测地址为d+1, d+2,d+3等，也就是从冲突地址往后面一个一个探测。
   + **线性补偿探测法**：它形成的探测地址为d+m,d+2m, d+3m等，与线性探测法不同，这里的查找单位不是1，而是m，为了能遍历到哈希表里所有位置，我们设置m和表长size互质。
   + **随机探测法**，这种方法和前两种方法类似，这里的查找单位不是一个固定值，而是一个随机序列。
   + **二次探测法**，它形成的探测地址为d+1^2, d-1^2, d+2^2, d-2^2等，这种方法在冲突位置左右跳跃着寻找探测地址。

   开放地址法计算简单快捷，处理起来方便，但是也存在不少缺点。

   线性探测法容易形成“堆聚”的情况，即很多记录就连在一块，而且一旦形成“堆聚”，记录会越聚越多。

   另外，开放地址法都有一个缺点，删除操作显得十分复杂，我们不能直接删除关键字所在的记录，否则在查找删除位置后面的元素时，可能会出现找不到的情况，因为删除位置上已经成了空地址，查找到这里时会终止查找。

3. **链地址法**

   该方法将所有哈希地址相同的结点链成一个单链表，单链表的头结点存在哈希数组里。链地址法常出现在经常插入和删除的情况下。

   相比开放地址法，链地址法有以下优点：

   + 不会出现“堆聚”现象，哈希地址不同的关键字不会发生冲突。

   + 不需要重建哈希表。

     在开放地址法中，如果哈希表里存满关键字了就需要扩充哈希表然后重建哈希表，而在链地址法里，因为结点都是动态申请的，所以不会出现哈希表里存满关键字的情况。

   + 关键字删除更方便，只需要找到指定结点的前驱，删除该结点即可。

4. 开放地址法和链地址法**各有千秋**，适用于不同的情况

   + 关键字规模少的时候，开放地址法比链地址法更省空间，因为用链地址法可能会存在哈希数组出现大量空地址的情况。
   + 关键字规模大的时候，链地址法就比开放地址法更省空间，链表产生的指针域可以忽略不计，关键字多，哈希数组里的空地址就少了。

5. 其他方法：**再哈希法、建立公共溢出区**



# 4.代码演示

处理冲突的方法以链地址法为例！！

![img](https://wx2.sinaimg.cn/mw690/005LasY6gy1gc7wnt779yj30ei0g1gm7.jpg)



## 4.1结构定义

```c
typedef struct Node {
  char *str;
  struct Node *next;
} Node;

typedef struct HashTable {
  Node **data;
  int size;
} HashTable;
```

## 4.2结构操作

#### 初始化与回收

```C
Node *init_Node(char *str, Node *head) {
  Node *p = (Node *)malloc(sizeof(Node));
  p->str = strdup(str);//将原来str字符串拷贝过来
  p->next = head;
  return p;
}

HashTable *init_HashTable(int n) {
  HashTable *h = (HashTable *)malloc(sizeof(HashTable));
  h->size = n << 1;//开两倍的空间
  h->data = (Node **)calloc(h->size, sizeof(Node *));
  return h;
}

void clear_Node(Node *node) {
  if (!node) return ;
  Node *p = node, *q;
  while (p) {
    q = p->next;
    free(p->str);
    free(p);
    p = q;
  }
  //free(q);
  return ;
}

void clear_HashTable(HashTable *h) {
  if (!h) return ;
  for (int i = 0; i < h->size; i++) {
    clear_Node(h->data[i]);
  }
  free(h->data);
  free(h);
}
```



#### 哈希函数

```C
int BKDRHash(char *str) {
  int seed = 31, hash = 0;
  for (int i = 0; str[i]; i++) hash = (hash * seed + str[i]);
  return hash & 0x7fffffff;
}
```

#### 插入表中

```C
int insert(HashTable *h, char *str) {
  int hash = BKDRHash(str);
  int ind = hash % h->size;//防止出界！！！
  h->data[ind] = init_Node(str, h->data[ind]);
  return 1;
}
```

#### 查找

```C
int search(HashTable *h, char *str) {
  int hash = BKDRHash(str);
  int ind = hash % h->size;
  Node *p = h->data[ind];
  while (p && strcmp(p->str, str)) {
    p = p->next;
  }
  return p != NULL;
}
```

