# 并查集

参考资料：

https://blog.csdn.net/dm_vincent/article/details/7655764

以及

https://blog.csdn.net/dm_vincent/article/details/7769159

## 用途

解决连通性问题

### 连通性问题



<img src="https://wx4.sinaimg.cn/mw690/005LasY6gy1gc6hvkybzbj312h0u0agh.jpg" alt="img" style="zoom: 200%;" />

1. 基于染色的思想，一开始所有点的颜色不同。
2. 连接两个点的操作，可以看成将一种颜色的点染成另一种颜色。
3. 如果两个点颜色一样，证明联通，否则不连通。
4. 这种方法叫做并查集的：Quick-Find算法。



### Quick-Find算法

#### 联通操作：

将后者替换掉前者所联通的所有点的数组元素

#### 总结

1. 联通判断：O(1)
2. 合并操作：O(n)



#### 思考

1. quick-find算法的联通判断非常快，可是合并操作非常慢。
2. 本质上问题中只是需要知道一个点与哪些点的颜色相同。
3. 而若干点的颜色可以通过间接指向同一个节点。
4. 合并操作时，实际上是将一棵树作为另一棵树的子树。



### Quick-Union算法

#### 联通操作：

若前者的代表元素为本身，则将后者的代表元素替换掉前者的代表元素(认后者为大哥)。若不为本身，追溯到代表元素为本身的元素去替换。

#### 总结

1. 联通判断：树高 O(logn)
2. 合并操作：树高 O(logn)

#### 思考

1. 极端情况下会退化成一条链表。
2. 将节点数量多的接到少的树上面，导致了退化。
3. 将树高 深的接到浅的上面，导致了退化。

#### 优化

若要改进，是按照节点数量还是按照树的高度为合并参考？